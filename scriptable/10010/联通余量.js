// Variables used by Scriptable.
// These must be at the very top of the file. Do not edit.
// icon-color: gray; icon-glyph: globe;
// Variables used by Scriptable.
// These must be at the very top of the file. Do not edit.
// icon-color: pink; icon-glyph: mobile-alt;
//
// iOS Ê°åÈù¢ÁªÑ‰ª∂ËÑöÊú¨ @„ÄåÂ∞è‰ª∂‰ª∂„Äç
// ÂºÄÂèëËØ¥ÊòéÔºöËØ∑‰ªé Widget Á±ªÂºÄÂßãÁºñÂÜôÔºåÊ≥®ÈáäËØ∑Âãø‰øÆÊîπ
// https://x.im3x.cn
//

// Ê∑ªÂä†requireÔºåÊòØ‰∏∫‰∫Üvscode‰∏≠ÂèØ‰ª•Ê≠£Á°ÆÂºïÂÖ•ÂåÖÔºå‰ª•Ëé∑ÂæóËá™Âä®Ë°•ÂÖ®Á≠âÂäüËÉΩ
if (typeof require === 'undefined') require = importModule
const { Base } = require('./„ÄåÂ∞è‰ª∂‰ª∂„ÄçÂºÄÂèëÁéØÂ¢É')

// @ÁªÑ‰ª∂‰ª£Á†ÅÂºÄÂßã
class Widget extends Base {
  /**
   * ‰º†ÈÄíÁªôÁªÑ‰ª∂ÁöÑÂèÇÊï∞ÔºåÂèØ‰ª•ÊòØÊ°åÈù¢ Parameter Êï∞ÊçÆÔºå‰πüÂèØ‰ª•ÊòØÂ§ñÈÉ®Â¶Ç URLScheme Á≠â‰º†ÈÄíÁöÑÊï∞ÊçÆ
   * @param {string} arg Ëá™ÂÆö‰πâÂèÇÊï∞
   */
  constructor(arg) {
    super(arg)
    this.name = 'ËÅîÈÄö‰ΩôÈáè'
    this.cacheKey = '10010_query'
    this.cookieCacheKey = '10010_query_cookie'
    this.url = 'chinaunicom://'
    this.setupGradient = async () => {
      // Requirements: sunrise
      // if (!sunData) { await setupSunrise() }
      const currentDate = new Date()
      const sunData = {
        sunrise: 1610492017000,
        sunset: 1610529162000,
      }
      // Determines if the provided date is at night.
      const isNight = dateInput => {
        const timeValue = dateInput.getTime()
        return timeValue < sunData.sunrise || timeValue > sunData.sunset
      }
      let gradient = {
        dawn: {
          color() {
            return [new Color('142C52'), new Color('1B416F'), new Color('62668B')]
          },
          position() {
            return [0, 0.5, 1]
          },
        },

        sunrise: {
          color() {
            return [new Color('274875'), new Color('766f8d'), new Color('f0b35e')]
          },
          position() {
            return [0, 0.8, 1.5]
          },
        },

        midday: {
          color() {
            return [new Color('3a8cc1'), new Color('90c0df')]
          },
          position() {
            return [0, 1]
          },
        },

        noon: {
          color() {
            return [new Color('b2d0e1'), new Color('80B5DB'), new Color('3a8cc1')]
          },
          position() {
            return [-0.2, 0.2, 1.5]
          },
        },

        sunset: {
          color() {
            return [new Color('32327A'), new Color('662E55'), new Color('7C2F43')]
          },
          position() {
            return [0.1, 0.9, 1.2]
          },
        },

        twilight: {
          color() {
            return [new Color('021033'), new Color('16296b'), new Color('414791')]
          },
          position() {
            return [0, 0.5, 1]
          },
        },

        night: {
          color() {
            return [new Color('16296b'), new Color('021033'), new Color('021033'), new Color('113245')]
          },
          position() {
            return [-0.5, 0.2, 0.5, 1]
          },
        },
      }

      const sunrise = sunData.sunrise
      const sunset = sunData.sunset
      const utcTime = currentDate.getTime()

      function closeTo(time, mins) {
        return Math.abs(utcTime - time) < mins * 60000
      }

      // Use sunrise or sunset if we're within 30min of it.
      if (closeTo(sunrise, 15)) {
        return gradient.sunrise
      }
      if (closeTo(sunset, 15)) {
        return gradient.sunset
      }

      // In the 30min before/after, use dawn/twilight.
      if (closeTo(sunrise, 45) && utcTime < sunrise) {
        return gradient.dawn
      }
      if (closeTo(sunset, 45) && utcTime > sunset) {
        return gradient.twilight
      }

      // Otherwise, if it's night, return night.
      if (isNight(currentDate)) {
        return gradient.night
      }

      // If it's around noon, the sun is high in the sky.
      if (currentDate.getHours() == 12) {
        return gradient.noon
      }
      // Otherwise, return the "typical" theme.
      return gradient.midday
    }
  }

  /**
   * Ê∏≤ÊüìÂáΩÊï∞ÔºåÂáΩÊï∞ÂêçÂõ∫ÂÆö
   * ÂèØ‰ª•Ê†πÊçÆ this.widgetFamily Êù•Âà§Êñ≠Â∞èÁªÑ‰ª∂Â∞∫ÂØ∏Ôºå‰ª•ËøîÂõû‰∏çÂêåÂ§ßÂ∞èÁöÑÂÜÖÂÆπ
   */
  async render() {
    try {
      const interval = this.arg || 60
      this.interval = interval
      let shouldFetch

      if (Keychain.contains(this.cacheKey)) {
        const cache = JSON.parse(Keychain.get(this.cacheKey))
        const list = cache.list
        const time = cache.time
        if ((new Date().getTime() - time) / 1000 / 60 > interval) {
          shouldFetch = true
        } else {
          list[list.length - 1].value += `/${interval}ÂàÜ`
          this.list = list
        }
      } else {
        shouldFetch = true
      }
      // shouldFetch = true
      if (shouldFetch) {
        let Cookie
        try {
          const boxjsReq = new Request('http://boxjs.net/query/boxdata')
          boxjsReq.timeoutInterval = 3
          boxjsReq.method = 'GET'
          const boxjsRes = await boxjsReq.loadJSON()
          Cookie = boxjsRes.datas['@10010_query.cookie'] || boxjsRes.datas['10010_query_cookie']
          console.log('‚úÖ ‰ªé boxjs ËØªÂèñ Cookie')
          //           console.log(`üç™ ${Cookie}`)
        } catch (e) {
          console.log('‚ùå ‰ªé boxjs ËØªÂèñ Cookie Â§±Ë¥•')
          console.error(e)
          try {
            Cookie = Keychain.get(this.cookieCacheKey)
            console.log('‚úÖ ‰ªé Keychain ËØªÂèñ Cookie')
            //             console.log(`üç™ ${Cookie}`)
          } catch (e) {
            console.log('‚ùå ‰ªé Keychain ËØªÂèñ Cookie Â§±Ë¥•')
            console.error(e)
          }
        }

        const checkCookieReq = async () => {
          try {
            const req = new Request('https://m.client.10010.com/servicequerybusiness/query/myInformation')
            // req.timeoutInterval = 30;
            req.method = 'GET'
            req.headers = {
              Cookie,
            }
            // req.body = ``;
            // return await req.loadJSON()
            let res = await req.loadString()
            console.log(res)
            res = JSON.parse(res)
            return res
          } catch (e) {
            console.error(e)
          }
        }
        const balanceReq = async () => {
          try {
            const req = new Request('https://m.client.10010.com/servicequerybusiness/balancenew/accountBalancenew.htm')
            // req.timeoutInterval = 30;
            req.method = 'GET'
            req.headers = {
              Cookie,
              // 'Content-Type': 'application/x-www-form-urlencoded',
            }
            // req.body = ``;
            // return await req.loadJSON();
            let res = await req.loadString()
            console.log(res)
            res = JSON.parse(res)
            return res
          } catch (e) {
            console.error(e)
          }
        }
        const pkgReq = async () => {
          try {
            const req = new Request(
              'https://m.client.10010.com/servicequerybusiness/operationservice/queryOcsPackageFlowLeftContent'
            )
            // req.timeoutInterval = 30;
            req.method = 'GET'
            req.headers = {
              Cookie,
              // 'Content-Type': 'application/x-www-form-urlencoded',
            }
            // req.body = ``;
            // return await req.loadJSON();
            let res = await req.loadString()
            console.log(res)
            res = JSON.parse(res)
            return res
          } catch (e) {
            console.error(e)
          }
        }
        const [balanceRes, pkgRes] = await Promise.all([balanceReq(), pkgReq()])
        let shouldCheckCookie
        if (balanceRes && balanceRes.code === '0000') {
          this.list = [
            {
              name: 'ËØùË¥π',
              color: 'e2e2e2',
              value: `¬•${balanceRes.curntbalancecust}`,
            },
          ]
        } else {
          this.list = [
            {
              name: 'ËØùË¥π',
              color: 'e2e2e2',
              value: `Á≥ªÁªüÁª¥Êä§`,
            },
          ]
          shouldCheckCookie = true
        }
        if (pkgRes && pkgRes.code === '0000' && pkgRes.resources) {
          let remains = 0

          pkgRes.resources.map(resource => {
            const { details, type } = resource
            if (type === 'flow') {
              details.map(detail => {
                let { addUpItemName, feePolicyName, remain, use, usedPercent } = detail
                remain = parseFloat(remain)
                use = parseFloat(use)
                let useTxt
                if (!isNaN(use)) {
                  if (use >= 1000) {
                    useTxt = `${(use / 1024).toFixed(2)}G`
                  } else {
                    useTxt = `${use}M`
                  }
                }
                usedPercent = parseFloat(usedPercent)
                if (!isNaN(usedPercent)) {
                  usedPercent.toFixed(2)
                }
                // Êó•Áßü
                if (/Êó•Áßü/.test(addUpItemName)) {
                  if (use > 1) {
                    this.list.push({
                      name: 'Â∑≤Áî®Êó•Áßü',
                      color: 'FF0000',
                      value: `${useTxt}`,
                    })
                  }
                } else if (!isNaN(remain) && remain > 0) {
                  remains += remain
                }
              })
            }
          })

          if (remains > 0) {
            let remainsTxt = remains.toFixed(2)
            if (remainsTxt >= 1000) {
              remainsTxt = `${(remainsTxt / 1024).toFixed(2)}G`
            } else {
              remainsTxt = `${remainsTxt}M`
            }
            if (remainsTxt) {
              this.list.push({
                name: 'Ââ©‰ΩôÊµÅÈáè',
                color: 'FF0000',
                value: `${remainsTxt}`,
              })
            }
          }

          let freeTxt
          if (pkgRes.summary) {
            const free = parseFloat(pkgRes.summary.freeFlow)
            if (!isNaN(free)) {
              if (free >= 1000) {
                freeTxt = `${(free / 1024).toFixed(2)}G`
              } else {
                freeTxt = `${free}M`
              }
            }
          }
          if (freeTxt) {
            this.list.push({
              name: 'Â∑≤Áî®ÂÖçÊµÅ',
              color: '32CD32',
              value: `${freeTxt}`,
            })
          }
        } else {
          shouldCheckCookie = true
        }
        // shouldCheckCookie = true
        if (shouldCheckCookie) {
          const checkCookieRes = await checkCookieReq()
          console.log(checkCookieRes)
          if (checkCookieRes && checkCookieRes.code === '0000') {
            this.list.push({
              name: 'Áä∂ÊÄÅ',
              color: 'e2e2e2',
              value: `Á≥ªÁªüÁª¥Êä§`,
            })
          } else {
            throw new Error('Cookie Â§±Êïà')
          }
        }

        this.list.push({
          name: 'Êõ¥Êñ∞',
          color: 'e2e2e2',
          value: [new Date().getHours(), new Date().getMinutes()].map(i => String(i).padStart(2, '0')).join(':'),
        })
        Keychain.set(
          this.cacheKey,
          JSON.stringify({
            list: this.list,
            time: new Date().getTime(),
          })
        )
        if (Cookie) {
          Keychain.set(this.cookieCacheKey, Cookie)
          console.log('‚úÖ Êú¨Ê¨°ËØ∑Ê±ÇÊàêÂäü ‰øùÂ≠ò Cookie Âà∞  Keychain')
        }
      }

      return await this[`${this.widgetFamily}Widget`]()
    } catch (e) {
      console.error(e)
      let notify = new Notification()
      notify.title = `‚ùå ${this.name}`
      notify.subtitle = `ÂèØÂ∞ùËØïÁÇπÂáªÈÄöÁü•ÊâìÂºÄ‰∏≠ÂõΩËÅîÈÄö ÈáçÊñ∞Ëé∑Âèñ Cookie`
      notify.openURL = this.url
      notify.body = String(e.message || e)
      await notify.schedule()
    }
  }

  /**
   * Ê∏≤ÊüìÂ∞èÂ∞∫ÂØ∏ÁªÑ‰ª∂
   */
  async smallWidget() {
    let w = new ListWidget()
    // let nextRefresh = Date.now() + 1000*60*this.interval // add interval miuntes to now
    // 	  w.refreshAfterDate = new Date(nextRefresh)
    w.addSpacer()

    this.list.map((v, i) => {
      const cell = w.addStack()
      cell.centerAlignContent()
      const name = cell.addText(v.name)
      name.font = Font.boldSystemFont(10)
      //       name.lineLimit = 2;
      if (i === 0) {
        name.textColor = new Color('#fe2d46', 1)
      } else if (i === 1) {
        name.textColor = new Color('#ff6600', 1)
      } else if (i === 2) {
        name.textColor = new Color('#faa90e', 1)
      } else if (i === 3) {
        name.textColor = new Color('#9195a3', 1)
      } else {
        name.textColor = new Color('#e2e2e2', 1)
      }
      cell.addSpacer()
      const value = cell.addText(v.value)
      value.font = Font.lightSystemFont(10)
      value.lineLimit = 1
      if (v.color) {
        value.textColor = new Color(v.color)
      }
      w.addSpacer()
    })
    w.url = this.url
    w.addSpacer()

    let gradient = new LinearGradient()
    let gradientSettings = await this.setupGradient()

    gradient.colors = gradientSettings.color()
    gradient.locations = gradientSettings.position()

    w.backgroundGradient = gradient

    return w
  }
  /**
   * Ê∏≤Êüì‰∏≠Â∞∫ÂØ∏ÁªÑ‰ª∂
   */
  async mediumWidget() {}
  /**
   * Ê∏≤ÊüìÂ§ßÂ∞∫ÂØ∏ÁªÑ‰ª∂
   */
  async largeWidget() {}

  /**
   * Ëá™ÂÆö‰πâÊ≥®ÂÜåÁÇπÂáª‰∫ã‰ª∂ÔºåÁî® actionUrl ÁîüÊàê‰∏Ä‰∏™Ëß¶ÂèëÈìæÊé•ÔºåÁÇπÂáªÂêé‰ºöÊâßË°å‰∏ãÊñπÂØπÂ∫îÁöÑ action
   * @param {string} url ÊâìÂºÄÁöÑÈìæÊé•
   */
  async actionOpenUrl(url) {
    Safari.openInApp(url, false)
  }
}
// @ÁªÑ‰ª∂‰ª£Á†ÅÁªìÊùü

const { Testing } = require('./„ÄåÂ∞è‰ª∂‰ª∂„ÄçÂºÄÂèëÁéØÂ¢É')
await Testing(Widget)
